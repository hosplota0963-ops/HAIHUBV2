local player = game.Players.LocalPlayer
local REQUIRED_KEY = "Luvhai"  -- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡∏µ‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

-- Services ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà
local UIS = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local Lighting = game:GetService("Lighting")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local Players = game:GetService("Players")

-- ‡∏™‡∏£‡πâ‡∏≤‡∏á UI ‡πÉ‡∏™‡πà‡∏Ñ‡∏µ‡∏¢‡πå‡πÅ‡∏ö‡∏ö‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°‡πÄ‡∏≠‡∏á
local ValidateKeyUI = Instance.new("ScreenGui")
ValidateKeyUI.Name = "HaiHubKeySystem"
ValidateKeyUI.Parent = player:WaitForChild("PlayerGui")
ValidateKeyUI.ResetOnSpawn = false
ValidateKeyUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

-- Main Frame ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏™‡∏ß‡∏¢‡∏á‡∏≤‡∏°
local MainFrame = Instance.new("Frame")
MainFrame.Size = UDim2.new(0, 500, 0, 350)
MainFrame.Position = UDim2.new(0.5, -250, 0.5, -175)
MainFrame.BackgroundColor3 = Color3.fromRGB(18, 18, 25)
MainFrame.BorderSizePixel = 0
MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
MainFrame.Parent = ValidateKeyUI

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 12)
UICorner.Parent = MainFrame

local UIStroke = Instance.new("UIStroke")
UIStroke.Color = Color3.fromRGB(0, 162, 255)
UIStroke.Thickness = 2
UIStroke.Transparency = 0.3
UIStroke.Parent = MainFrame

-- Gradient Background
local BackgroundGradient = Instance.new("UIGradient")
BackgroundGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(25, 25, 35)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(15, 15, 20))
}
BackgroundGradient.Rotation = 45
BackgroundGradient.Parent = MainFrame

-- Title Section
local TitleFrame = Instance.new("Frame")
TitleFrame.Size = UDim2.new(1, 0, 0, 80)
TitleFrame.Position = UDim2.new(0, 0, 0, 0)
TitleFrame.BackgroundColor3 = Color3.fromRGB(0, 162, 255)
TitleFrame.BorderSizePixel = 0
TitleFrame.Parent = MainFrame

local TitleGradient = Instance.new("UIGradient")
TitleGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(0, 162, 255)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(0, 120, 200))
}
TitleGradient.Rotation = 90
TitleGradient.Parent = TitleFrame

local TitleCorner = Instance.new("UICorner")
TitleCorner.CornerRadius = UDim.new(0, 12)
TitleCorner.Parent = TitleFrame

local TitleLabel = Instance.new("TextLabel")
TitleLabel.Text = "üöÄ HAIHUB PREMIUM ACCESS üöÄ"
TitleLabel.Size = UDim2.new(1, -20, 1, 0)
TitleLabel.Position = UDim2.new(0, 10, 0, 0)
TitleLabel.BackgroundTransparency = 1
TitleLabel.Font = Enum.Font.GothamBlack
TitleLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleLabel.TextSize = 24
TitleLabel.TextStrokeTransparency = 0.8
TitleLabel.TextXAlignment = Enum.TextXAlignment.Center
TitleLabel.Parent = TitleFrame

-- Subtitle
local SubtitleLabel = Instance.new("TextLabel")
SubtitleLabel.Text = "‡πÉ‡∏™‡πà‡∏Ñ‡∏µ‡∏¢‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏£‡∏∞‡∏ö‡∏ö Premium"
SubtitleLabel.Size = UDim2.new(1, -20, 0, 30)
SubtitleLabel.Position = UDim2.new(0, 10, 0, 100)
SubtitleLabel.BackgroundTransparency = 1
SubtitleLabel.Font = Enum.Font.GothamSemibold
SubtitleLabel.TextColor3 = Color3.fromRGB(180, 180, 190)
SubtitleLabel.TextSize = 16
SubtitleLabel.TextXAlignment = Enum.TextXAlignment.Center
SubtitleLabel.Parent = MainFrame

-- Key Input Section
local InputFrame = Instance.new("Frame")
InputFrame.Size = UDim2.new(1, -40, 0, 60)
InputFrame.Position = UDim2.new(0, 20, 0, 160)
InputFrame.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
InputFrame.BorderSizePixel = 0
InputFrame.Parent = MainFrame

local InputCorner = Instance.new("UICorner")
InputCorner.CornerRadius = UDim.new(0, 8)
InputCorner.Parent = InputFrame

local InputStroke = Instance.new("UIStroke")
InputStroke.Color = Color3.fromRGB(60, 60, 80)
InputStroke.Thickness = 1
InputStroke.Parent = InputFrame

local KeyTextBox = Instance.new("TextBox")
KeyTextBox.Size = UDim2.new(1, -20, 1, 0)
KeyTextBox.Position = UDim2.new(0, 10, 0, 0)
KeyTextBox.BackgroundTransparency = 1
KeyTextBox.Font = Enum.Font.GothamBold
KeyTextBox.Text = ""
KeyTextBox.PlaceholderText = "üîë ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡∏µ‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."
KeyTextBox.TextColor3 = Color3.fromRGB(255, 255, 255)
KeyTextBox.PlaceholderColor3 = Color3.fromRGB(120, 120, 140)
KeyTextBox.TextSize = 18
KeyTextBox.TextXAlignment = Enum.TextXAlignment.Center
KeyTextBox.ClearTextOnFocus = false
KeyTextBox.Parent = InputFrame

-- Submit Button
local SubmitButton = Instance.new("TextButton")
SubmitButton.Size = UDim2.new(0, 200, 0, 50)
SubmitButton.Position = UDim2.new(0.5, -100, 0, 250)
SubmitButton.BackgroundColor3 = Color3.fromRGB(0, 200, 100)
SubmitButton.BorderSizePixel = 0
SubmitButton.Text = "‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡πÅ‡∏•‡∏∞‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô"
SubmitButton.Font = Enum.Font.GothamBlack
SubmitButton.TextColor3 = Color3.fromRGB(255, 255, 255)
SubmitButton.TextSize = 18
SubmitButton.AutoButtonColor = true
SubmitButton.Parent = MainFrame

local ButtonCorner = Instance.new("UICorner")
ButtonCorner.CornerRadius = UDim.new(0, 25)
ButtonCorner.Parent = SubmitButton

local ButtonGradient = Instance.new("UIGradient")
ButtonGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0.0, Color3.fromRGB(0, 200, 100)),
    ColorSequenceKeypoint.new(1.0, Color3.fromRGB(0, 160, 80))
}
ButtonGradient.Rotation = 90
ButtonGradient.Parent = SubmitButton

-- Error Label (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏µ‡∏¢‡πå‡∏ú‡∏¥‡∏î)
local ErrorLabel = Instance.new("TextLabel")
ErrorLabel.Size = UDim2.new(1, -20, 0, 25)
ErrorLabel.Position = UDim2.new(0, 10, 0, 310)
ErrorLabel.BackgroundTransparency = 1
ErrorLabel.Font = Enum.Font.GothamBold
ErrorLabel.Text = ""
ErrorLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
ErrorLabel.TextSize = 14
ErrorLabel.TextXAlignment = Enum.TextXAlignment.Center
ErrorLabel.Visible = false
ErrorLabel.Parent = MainFrame

-- ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏ö‡∏≠‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ú‡πà‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡πá‡∏Ñ Key
local keyAccepted = false

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô FastMode (‡∏•‡∏î‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡πÇ‡∏•‡∏ß)
local FastModeEnabled = false
local OriginalSettings = {
    lighting = {},
    terrain = {},
    instances = {}
}

local function FastMode(mode)
    local Terrain = workspace:FindFirstChildOfClass('Terrain')
    
    if mode == "ENABLE" then
        -- ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
        OriginalSettings.lighting.GlobalShadows = Lighting.GlobalShadows
        OriginalSettings.lighting.FogEnd = Lighting.FogEnd
        OriginalSettings.lighting.Brightness = Lighting.Brightness
        OriginalSettings.lighting.EnvironmentDiffuseScale = Lighting.EnvironmentDiffuseScale
        OriginalSettings.lighting.EnvironmentSpecularScale = Lighting.EnvironmentSpecularScale
        OriginalSettings.lighting.OutdoorAmbient = Lighting.OutdoorAmbient
        
        -- ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÇ‡∏•‡∏ß‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 200
        Lighting.Brightness = 1
        Lighting.EnvironmentDiffuseScale = 0
        Lighting.EnvironmentSpecularScale = 0
        Lighting.OutdoorAmbient = Color3.fromRGB(128, 128, 128)
        
        -- ‡∏õ‡∏¥‡∏î‡πÄ‡∏≠‡∏ü‡πÄ‡∏ü‡∏Å‡∏ï‡πå‡∏ï‡πà‡∏≤‡∏á‡πÜ
        for _, effect in pairs(Lighting:GetChildren()) do
            if effect:IsA("BloomEffect") or effect:IsA("ColorCorrectionEffect") or
               effect:IsA("SunRaysEffect") or effect:IsA("DepthOfFieldEffect") or effect:IsA("BlurEffect") then
                OriginalSettings.instances[effect] = effect.Enabled
                effect.Enabled = false
            end
        end
        
        -- ‡∏õ‡∏£‡∏±‡∏ö Terrain
        if Terrain then
            OriginalSettings.terrain.WaterWaveSize = Terrain.WaterWaveSize
            OriginalSettings.terrain.WaterWaveSpeed = Terrain.WaterWaveSpeed
            OriginalSettings.terrain.WaterReflectance = Terrain.WaterReflectance
            OriginalSettings.terrain.WaterTransparency = Terrain.WaterTransparency
            
            Terrain.WaterWaveSize = 0
            Terrain.WaterWaveSpeed = 0
            Terrain.WaterReflectance = 0
            Terrain.WaterTransparency = 1
            
            pcall(function()
                OriginalSettings.terrain.Decoration = Terrain.Decoration
                Terrain.Decoration = false
            end)
        end
        
        -- ‡∏õ‡∏£‡∏±‡∏ö‡∏Ç‡∏≠‡∏á‡πÉ‡∏ô workspace
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("ParticleEmitter") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Trail") or obj:IsA("Beam") then
                OriginalSettings.instances[obj] = obj.Enabled
                obj.Enabled = false
            elseif obj:IsA("PointLight") or obj:IsA("SpotLight") or obj:IsA("SurfaceLight") then
                OriginalSettings.instances[obj] = {
                    Shadows = obj.Shadows,
                    Brightness = obj.Brightness,
                    Range = obj.Range
                }
                obj.Shadows = false
                obj.Brightness = math.min(obj.Brightness, 0.5)
                obj.Range = math.min(obj.Range, 8)
            elseif obj:IsA("MeshPart") or obj:IsA("BasePart") then
                if not OriginalSettings.instances[obj] then
                    OriginalSettings.instances[obj] = {
                        Material = obj.Material,
                        Reflectance = obj.Reflectance,
                        CastShadow = obj.CastShadow
                    }
                end
                obj.Material = Enum.Material.Plastic
                obj.Reflectance = 0
                obj.CastShadow = false
            elseif obj:IsA("Decal") or obj:IsA("Texture") then
                OriginalSettings.instances[obj] = obj.Transparency
                obj.Transparency = 0.8
            end
        end
        
        FastModeEnabled = true
        StarterGui:SetCore("SendNotification", {
            Title = "FastMode",
            Text = "‡πÇ‡∏•‡∏ß‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡πÄ‡∏õ‡∏¥‡∏î‡πÅ‡∏•‡πâ‡∏ß - ‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô",
            Duration = 3
        })
        
    elseif mode == "DISABLE" then
        -- ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏î‡∏¥‡∏°
        for prop, value in pairs(OriginalSettings.lighting) do
            Lighting[prop] = value
        end
        
        for obj, value in pairs(OriginalSettings.instances) do
            if obj and obj.Parent then
                if typeof(value) == "boolean" then
                    obj.Enabled = value
                elseif typeof(value) == "table" then
                    for prop, val in pairs(value) do
                        pcall(function() obj[prop] = val end)
                    end
                else
                    pcall(function() obj.Transparency = value end)
                end
            end
        end
        
        if Terrain then
            for prop, value in pairs(OriginalSettings.terrain) do
                pcall(function() Terrain[prop] = value end)
            end
        end
        
        FastModeEnabled = false
        StarterGui:SetCore("SendNotification", {
            Title = "FastMode",
            Text = "‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡∏õ‡∏Å‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß",
            Duration = 3
        })
    end
end

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Fly (‡∏ö‡∏¥‡∏ô‡∏ô‡∏¥‡πà‡∏á‡πÜ ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡πÑ‡∏î‡πâ)
local FlyActive = false
local FlySpeed = 80
local FlyKeys = {W = false, A = false, S = false, D = false, Up = false, Down = false}
local FlyRoot, FlyHumanoid
local FlyDrive
local FlyTweenConn
local FlyStep = 0.06

local function antiInvisible(character)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            pcall(function()
                part.LocalTransparencyModifier = 0
            end)
        elseif part:IsA("Decal") or part:IsA("Texture") then
            pcall(function()
                part.Transparency = 0
            end)
        end
    end
end

local function setNoCollide(character, state)
    for _, part in pairs(character:GetDescendants()) do
        if part:IsA("BasePart") then
            part.CanCollide = not state
        end
    end
end

local function bindFlyCharacter(character)
    FlyHumanoid = character:FindFirstChildOfClass("Humanoid") or character:WaitForChild("Humanoid", 10)
    FlyRoot = character:FindFirstChild("HumanoidRootPart") or character:WaitForChild("HumanoidRootPart", 10)
    antiInvisible(character)
end

bindFlyCharacter(player.Character or player.CharacterAdded:Wait())
player.CharacterAdded:Connect(bindFlyCharacter)

local function startFly()
    if FlyActive or not FlyRoot or not FlyHumanoid then return end
    
    FlyActive = true
    FlyHumanoid.PlatformStand = true
    FlyHumanoid.AutoRotate = false
    FlyHumanoid.WalkSpeed = 0
    FlyHumanoid.JumpPower = 0
    setNoCollide(player.Character, true)
    antiInvisible(player.Character)
    FlyRoot.Anchored = true
    
    FlyDrive = Instance.new("CFrameValue")
    FlyDrive.Value = FlyRoot.CFrame
    FlyTweenConn = FlyDrive.Changed:Connect(function(cf)
        if FlyRoot then
            FlyRoot.CFrame = cf
        end
    end)
    
    StarterGui:SetCore("SendNotification", {
        Title = "Fly",
        Text = "‡πÄ‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ö‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß - ‡πÉ‡∏ä‡πâ WASD + Space/Ctrl ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°",
        Duration = 3
    })
    
    coroutine.wrap(function()
        while FlyActive and FlyDrive do
            local direction = Vector3.zero
            local camera = workspace.CurrentCamera
            local lookVector = camera.CFrame.LookVector
            local rightVector = camera.CFrame.RightVector
            
            if FlyKeys.W then direction = direction + lookVector end
            if FlyKeys.S then direction = direction - lookVector end
            if FlyKeys.D then direction = direction + rightVector end
            if FlyKeys.A then direction = direction - rightVector end
            
            local upDown = 0
            if FlyKeys.Up then upDown = upDown + 1 end
            if FlyKeys.Down then upDown = upDown - 1 end
            
            if direction.Magnitude > 0 then
                direction = direction.Unit
            end
            
            local flatLook = Vector3.new(lookVector.X, 0, lookVector.Z)
            if flatLook.Magnitude > 0 then
                flatLook = flatLook.Unit
            end
            
            local currentPos = FlyDrive.Value.Position
            local delta = (direction * FlySpeed + Vector3.new(0, upDown * FlySpeed, 0)) * FlyStep
            local targetPos = currentPos + delta
            local targetCFrame = CFrame.new(targetPos, targetPos + flatLook)
            
            local tween = TweenService:Create(FlyDrive, TweenInfo.new(FlyStep, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {Value = targetCFrame})
            tween:Play()
            
            task.wait(FlyStep * 0.95)
        end
        
        if FlyRoot then
            FlyRoot.Anchored = false
        end
    end)()
end

local function stopFly()
    if not FlyActive then return end
    
    FlyActive = false
    
    if FlyTweenConn then
        FlyTweenConn:Disconnect()
        FlyTweenConn = nil
    end
    
    if FlyDrive then
        FlyDrive:Destroy()
        FlyDrive = nil
    end
    
    if FlyHumanoid then
        FlyHumanoid.PlatformStand = false
        FlyHumanoid.AutoRotate = true
        FlyHumanoid.WalkSpeed = 16
        FlyHumanoid.JumpPower = 50
    end
    
    if player.Character then
        setNoCollide(player.Character, false)
    end
    
    if FlyRoot then
        FlyRoot.Anchored = false
    end
    
    StarterGui:SetCore("SendNotification", {
        Title = "Fly",
        Text = "‡∏õ‡∏¥‡∏î‡πÇ‡∏´‡∏°‡∏î‡∏ö‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
        Duration = 3
    })
end

local function toggleFly()
    if FlyActive then
        stopFly()
    else
        startFly()
    end
end

-- Controls ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Fly
UIS.InputBegan:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    local key = input.KeyCode
    if key == Enum.KeyCode.M then
        toggleFly()
    elseif key == Enum.KeyCode.W then
        FlyKeys.W = true
    elseif key == Enum.KeyCode.A then
        FlyKeys.A = true
    elseif key == Enum.KeyCode.S then
        FlyKeys.S = true
    elseif key == Enum.KeyCode.D then
        FlyKeys.D = true
    elseif key == Enum.KeyCode.Space then
        FlyKeys.Up = true
    elseif key == Enum.KeyCode.LeftControl then
        FlyKeys.Down = true
    elseif key == Enum.KeyCode.F1 then
        if FastModeEnabled then
            FastMode("DISABLE")
        else
            FastMode("ENABLE")
        end
    end
end)

UIS.InputEnded:Connect(function(input, gameProcessed)
    if gameProcessed then return end
    
    local key = input.KeyCode
    if key == Enum.KeyCode.W then
        FlyKeys.W = false
    elseif key == Enum.KeyCode.A then
        FlyKeys.A = false
    elseif key == Enum.KeyCode.S then
        FlyKeys.S = false
    elseif key == Enum.KeyCode.D then
        FlyKeys.D = false
    elseif key == Enum.KeyCode.Space then
        FlyKeys.Up = false
    elseif key == Enum.KeyCode.LeftControl then
        FlyKeys.Down = false
    end
end)

-- ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡∏¥‡∏î UI ‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏° 100% ‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏¥‡πà‡∏° Utility Section)
local function createMainUI()
    local NothingLibrary = loadstring(game:HttpGetAsync('https://raw.githubusercontent.com/3345-c-a-t-s-u-s/NOTHING/main/source.lua'))()
    local Windows = NothingLibrary.new({
        Title = "Haihub",
        Description = "Nothing UI Library",
        Keybind = Enum.KeyCode.LeftControl,
        Logo = 'http://www.roblox.com/asset/?id=18898582662'
    })
    local mainTab = Windows:NewTab({
        Title = "Main",
        Description = "Main category",
        Icon = "rbxassetid://7733960981"
    })
    local mainSection = mainTab:NewSection({
        Title = "AutoFarm Section",
        Icon = "rbxassetid://7743869054",
        Position = "Left"
    })
    
    -- ‡πÄ‡∏û‡∏¥‡πà‡∏° Utility Section ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FastMode ‡πÅ‡∏•‡∏∞ Fly
    local utilitySection = mainTab:NewSection({
        Title = "Utility Section",
        Icon = "rbxassetid://7743869322",
        Position = "Right"
    })
    
    -- Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö FastMode
    utilitySection:NewToggle({
        Title = "FastMode (‡πÇ‡∏•‡∏ß‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å)",
        Description = "‡∏•‡∏î‡∏Å‡∏£‡∏≤‡∏ü‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û (F1)",
        Default = false,
        Callback = function(state)
            if state then
                FastMode("ENABLE")
            else
                FastMode("DISABLE")
            end
        end,
    })
    
    -- Toggle ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Fly
    utilitySection:NewToggle({
        Title = "Fly (‡∏ö‡∏¥‡∏ô)",
        Description = "‡∏ö‡∏¥‡∏ô‡∏ô‡∏¥‡πà‡∏á‡πÜ ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏î‡πâ‡∏ß‡∏¢ WASD + Space/Ctrl (M)",
        Default = false,
        Callback = function(state)
            if state then
                startFly()
            else
                stopFly()
            end
        end,
    })
    
    -- Slider ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ö‡∏¥‡∏ô
    utilitySection:NewSlider({
        Title = "‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏ö‡∏¥‡∏ô",
        Description = "‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏¥‡∏ô",
        Default = FlySpeed,
        Min = 10,
        Max = 200,
        Callback = function(value)
            FlySpeed = value
        end,
    })
    
    -- ‡πÇ‡∏Ñ‡πâ‡∏î AutoFarm ‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î (‡πÑ‡∏°‡πà‡∏ï‡∏±‡∏î ‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô)
    local autofarmActive = false
    local vim = game:GetService('VirtualInputManager')
    local targetPartName = "BallShadow"
    local RunService = game:GetService("RunService")
    local heightMultiplier = 3
    local savePoints = {
        Vector3.new(-635.617, -511.303, -161.760),
        Vector3.new(-674.005, -511.303, -160.835),
        Vector3.new(-698.223, -511.303, -171.372),
        Vector3.new(-611.828, -511.303, -170.489),
        Vector3.new(-654.880, -511.306, -166.939),
        Vector3.new(-700.217, -511.303, 26.219),
        Vector3.new(-657.019, -511.303, 26.620),
        Vector3.new(-611.098, -511.303, 26.832),
        Vector3.new(-635.081, -511.303, 25.963),
        Vector3.new(-673.481, -511.303, 26.082),
    }
    local isPaused = false
    local pauseDuration = 3
    local pauseDistance = 10
    local Teams = game:GetService("Teams")
    local function isNearSavePoint(position)
        for _, sp in ipairs(savePoints) do
            if (position - sp).Magnitude <= pauseDistance then
                return true
            end
        end
        return false
    end
    local function findTarget()
        for _, part in pairs(workspace:GetDescendants()) do
            if part:IsA("BasePart") and part.Name == targetPartName then
                return part
            end
        end
        return nil
    end
    local function enableFlying(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.PlatformStand = true
        end
    end
    local function disableFlying(character)
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if humanoid then
            humanoid.PlatformStand = false
        end
    end
    local function moveToTargetFly(part)
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp and part then
            local baseHeight = part.Size.Y / 2 + 5
            local heightOffset = baseHeight * heightMultiplier
            hrp.CFrame = CFrame.new(part.Position + Vector3.new(0, heightOffset, 0), part.Position)
        end
    end
    local function spamF()
        vim:SendKeyEvent(true, Enum.KeyCode.F, false, game)
        vim:SendKeyEvent(false, Enum.KeyCode.F, false, game)
    end
    local function findClosestEnemyPlayer()
        local char = player.Character
        if not char then return nil end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return nil end
        local myTeam = player.Team
        local closestPlayer = nil
        local closestDistance = math.huge
        for _, plr in pairs(game.Players:GetPlayers()) do
            if plr ~= player and plr.Character and plr.Character:FindFirstChild("HumanoidRootPart") and plr.Team ~= myTeam then
                local targetHRP = plr.Character.HumanoidRootPart
                local dist = (hrp.Position - targetHRP.Position).Magnitude
                if dist < closestDistance then
                    closestDistance = dist
                    closestPlayer = plr
                end
            end
        end
        return closestPlayer
    end
    local function faceTarget(targetPos)
        local char = player.Character
        if not char then return end
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if hrp then
            local lookVector = (targetPos - hrp.Position).Unit
            local newCFrame = CFrame.new(hrp.Position, hrp.Position + lookVector)
            local _, yaw, _ = newCFrame:ToEulerAnglesYXZ()
            local currentCFrame = hrp.CFrame
            hrp.CFrame = CFrame.new(currentCFrame.Position) * CFrame.Angles(0, yaw, 0)
        end
    end
    local function autoHit()
        coroutine.wrap(function()
            while true do
                if autofarmActive and not isPaused then
                    spamF()
                end
                task.wait(0.01)
            end
        end)()
        while not autofarmActive do
            task.wait()
        end
        enableFlying(player.Character or player.CharacterAdded:Wait())
        while autofarmActive do
            local char = player.Character
            if not char then break end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                if isNearSavePoint(hrp.Position) and not isPaused then
                    isPaused = true
                    task.wait(pauseDuration)
                    isPaused = false
                end
            end
            if not isPaused then
                local enemy = findClosestEnemyPlayer()
                if enemy and enemy.Character and enemy.Character:FindFirstChild("HumanoidRootPart") then
                    faceTarget(enemy.Character.HumanoidRootPart.Position)
                end
                local target = findTarget()
                if target then
                    moveToTargetFly(target)
                end
            end
            task.wait(0.1)
        end
        disableFlying(player.Character or player.CharacterAdded:Wait())
    end
    mainSection:NewSlider({
        Title = "Height Multiplier",
        Default = heightMultiplier,
        Min = 1,
        Max = 10,
        Callback = function(value)
            heightMultiplier = value
        end,
    })
    mainSection:NewToggle({
        Title = "Auto Farm",
        Default = false,
        Callback = function(state)
            autofarmActive = state
            if state then
                autoHit()
            end
        end,
    })
    local autoMoneyActive = false
    local SCAN_INTERVAL = 3
    local CLICK_OFFSET_Y = 20
    local clickedCache = {}
    local lastCacheFlush = 0
    local MAX_MARKERS = 4
    local markers = {}
    local VIM = game:GetService("VirtualInputManager")
    local function newMarker()
        local sq = Drawing.new("Square")
        sq.Thickness = 2
        sq.Filled = false
        sq.Transparency = 1
        sq.Color = Color3.fromRGB(255, 255, 0)
        return sq
    end
    local function clearMarkers()
        for _, marker in ipairs(markers) do
            if marker.draw then
                marker.draw:Remove()
            end
        end
        table.clear(markers)
    end
    local function addMarkerFor(guiObj)
        if #markers >= MAX_MARKERS then return end
        local draw = newMarker()
        table.insert(markers, {inst = guiObj, draw = draw})
    end
    local function updateMarkers()
        for i = #markers, 1, -1 do
            local m = markers[i]
            local inst = m.inst
            local draw = m.draw
            if not inst or not inst.Parent or not draw then
                draw:Remove()
                table.remove(markers, i)
            else
                local okPos, pos = pcall(function() return inst.AbsolutePosition end)
                local okSize, size = pcall(function() return inst.AbsoluteSize end)
                local okVis, vis = pcall(function() return inst.Visible end)
                if okPos and okSize and okVis and vis and size.X > 0 and size.Y > 0 then
                    draw.Visible = true
                    draw.Position = Vector2.new(pos.X, pos.Y)
                    draw.Size = Vector2.new(size.X, size.Y)
                else
                    draw.Visible = false
                end
            end
        end
    end
    local function isActuallyVisible(guiObj)
        local current = guiObj
        while current and current ~= game do
            local ok, vis = pcall(function() return current.Visible end)
            if ok and not vis then return false end
            current = current.Parent
        end
        local okPos, pos = pcall(function() return guiObj.AbsolutePosition end)
        local okSize, size = pcall(function() return guiObj.AbsoluteSize end)
        if not okPos or not okSize then return false end
        if size.X <= 0 or size.Y <= 0 then return false end
        local viewport = workspace.CurrentCamera and workspace.CurrentCamera.ViewportSize or Vector2.new(1920, 1080)
        if pos.X > viewport.X or pos.Y > viewport.Y or pos.X + size.X < 0 or pos.Y + size.Y < 0 then return false end
        return true
    end
    local function getTextOf(obj)
        local ok, txt = pcall(function() return obj.Text end)
        if ok and type(txt) == "string" and #txt > 0 then return txt end
        return nil
    end
    local function safeClick(inst)
        local now = tick()
        if clickedCache[inst] and now - clickedCache[inst] < 0.25 then return end
        clickedCache[inst] = now
        pcall(function()
            local pos = inst.AbsolutePosition
            local size = inst.AbsoluteSize
            local x = pos.X + size.X / 2
            local y = pos.Y + size.Y / 2 + CLICK_OFFSET_Y
            VIM:SendMouseButtonEvent(x, y, 0, true, game, 0)
            task.wait(0.02)
            VIM:SendMouseButtonEvent(x, y, 0, false, game, 0)
        end)
    end
    local function getGuiRoots()
        local roots = {}
        local pg = nil
        pcall(function()
            pg = player:WaitForChild("PlayerGui", 5)
        end)
        if pg then table.insert(roots, pg) end
        local cg = nil
        pcall(function()
            cg = game:GetService("CoreGui")
        end)
        if cg then table.insert(roots, cg) end
        return roots
    end
    local function teleportToPosition()
        local char = player.Character or player.CharacterAdded:Wait()
        local hrp = char:WaitForChild("HumanoidRootPart")
        hrp.CFrame = CFrame.new(93.651, -460.362, -70.619)
    end
    local function clickButtonsStep()
        local firstButtonClicked = false
        local secondButtonClicked = false
        local function findAndClickButtonWithText(text)
            local roots = getGuiRoots()
            for _, root in ipairs(roots) do
                for _, obj in ipairs(root:GetDescendants()) do
                    if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and isActuallyVisible(obj) then
                        local txt = getTextOf(obj)
                        if txt and txt:lower():find(text:lower(), 1, true) then
                            safeClick(obj)
                            return true
                        end
                    end
                end
            end
            return false
        end
        teleportToPosition()
        task.wait(1)
        while not firstButtonClicked and autoMoneyActive do
            firstButtonClicked = findAndClickButtonWithText("2 v 2")
            task.wait(0.5)
        end
        while not secondButtonClicked and autoMoneyActive do
            secondButtonClicked = findAndClickButtonWithText("find match")
            task.wait(0.5)
        end
    end
    local function scanAndClickLoop()
        while autoMoneyActive do
            local success, err = pcall(function()
                local roots = getGuiRoots()
                local foundList = {}
                local isJoinFound = false
                local MATCH_WORD = "join"
                for _, root in ipairs(roots) do
                    for _, obj in ipairs(root:GetDescendants()) do
                        if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and isActuallyVisible(obj) then
                            local txt = getTextOf(obj)
                            if txt and txt:lower():find(MATCH_WORD, 1, true) then
                                table.insert(foundList, obj)
                                isJoinFound = true
                            end
                        end
                    end
                end
                clearMarkers()
                for i, inst in ipairs(foundList) do
                    if i <= MAX_MARKERS then
                        addMarkerFor(inst)
                    end
                    if isJoinFound then
                        safeClick(inst)
                    end
                end
                updateMarkers()
            end)
            if not success then
                warn("[Auto Money] error:", err)
            end
            task.wait(SCAN_INTERVAL)
        end
    end
    mainSection:NewToggle({
        Title = "Auto Money",
        Default = false,
        Callback = function(state)
            autoMoneyActive = state
            if state then
                coroutine.wrap(clickButtonsStep)()
                coroutine.wrap(scanAndClickLoop)()
            end
        end,
    })
end

-- ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î‡∏õ‡∏∏‡πà‡∏° Submit
SubmitButton.MouseButton1Click:Connect(function()
    local enteredKey = KeyTextBox.Text
    if enteredKey == REQUIRED_KEY then
        ValidateKeyUI:Destroy()
        keyAccepted = true
        createMainUI()
        -- ‡πÄ‡∏≠‡∏≤ auto enable ‡∏≠‡∏≠‡∏Å (‡πÅ‡∏Å‡πâ‡πÅ‡∏Ñ‡πà‡∏ï‡∏£‡∏á‡∏ô‡∏µ‡πâ)
    else
        KeyTextBox.Text = ""
        KeyTextBox.PlaceholderText = "‚ùå ‡∏Ñ‡∏µ‡∏¢‡πå‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
        ErrorLabel.Text = "üõë ‡∏Ñ‡∏µ‡∏¢‡πå‡∏ú‡∏¥‡∏î! ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÉ‡∏™‡πà‡πÉ‡∏´‡∏°‡πà‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á"
        ErrorLabel.Visible = true
        
        -- ‡∏ã‡πà‡∏≠‡∏ô‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° error ‡∏´‡∏•‡∏±‡∏á‡∏à‡∏≤‡∏Å 3 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
        task.wait(3)
        ErrorLabel.Visible = false
        KeyTextBox.PlaceholderText = "üîë ‡∏Å‡∏£‡∏≠‡∏Å‡∏Ñ‡∏µ‡∏¢‡πå‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà..."
    end
end)

-- ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏î Enter ‡πÉ‡∏ô‡∏ä‡πà‡∏≠‡∏á‡πÉ‡∏™‡πà‡∏Ñ‡∏µ‡∏¢‡πå
KeyTextBox.FocusLost:Connect(function(enterPressed)
    if enterPressed then
        SubmitButton.MouseButton1Click:Fire()
    end
end)
